** 알게 된 것 **
1. 프로그램 에러에는 컴파일 에러와 런타임 에러가 있다. 컴파일 에러는 컴파일 할 때 생기는 거고 런타임 에러는 실행도중에 생기는 에러다.
프로그램 실행 도중 에러가 난다는 게 무슨 말? - 실행 중 동작을 멈춘 채로 오래 지속되거나 갑자기 실행 종료되는 경우
Java에서는 런타임 에러를 error와 exception 2가지로 구분한다.
error : 메모리부족(OutoOfMemoryError)나 스택오버플로우(StackOverflowError)와 같이 심각한 것
exception : 덜 심각한 것 -> exception handling을 통해 비정상 종료를 막고 정상적인 실행상태 유지 가능

try{
} catch (Exception1 e1) {
	// Exception1이 발생할 경우 처리하기 위한 코드 적는다.
}

2. try문 안에서 에러 발생하면 에러 발생한 줄 밑의 줄들은 실행 안 되고 바로 catch문으로 넘어간다.

3. throw를 이용해서 고의로 예외를 발생시킬 수도 있다.
1) 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든 다음,
Exception e = new Exception("고의로 발생시켰음");
2) 키워드 throw를 이용해서 예외를 발생시킨다.
throw e;

4. Exception 클래스와 Error 클래스 역시 모두 Object 클래스의 자손이다.
Exception 클래스는 RuntimeException 클래스들과 그 외 Exception클래스들 로 나뉜다.
RuntimeException은 주로 프로그래머의 실수에 의해 생긴다.(ex. 배열의 범위 벗어남 - IndexOutOfBoundsException, 값이 null인 참조변수의 멤버를 호출 - NullPointerException, 클래스 형변환 오류 - ClassCastException, 0으로 나누기 - ArithmeticException , etc)
이런 오류들은 오류를 잡을 생각을 할 게 아니고 처음에 짤 떄 잘 짜야 된다.
그 외 Exception들은 외부 영향에 주로 의한다. (ex. 존재하지 않는 파일의 이름 입력 - FileNotFoundException, 클래스 이름 잘못 적음 - ClassNotFoundException, 입력한 데이터 형식 잘못됨 - DataFormatException, etc)
이런 애들은 반드시 예외 처리 해줘야 된다!

이 둘의 차이점은 컴파일 시에 있다.
RuntimeException들은 예외처리 안 해줘도 컴파일 되지만, 그 외 Exception들은 컴파일 하면 에러 뜬다.

5. 그 어떤 종류의 Exception이라도 catch에 Exception e 써놓으면 되긴 되는데 왜냐면 모든 Excpetion의 조상 클래스가 Exception이기 때문

6. finally는 예외에 상관없이 무조건 실행되는 블럭이다.

7. 메서드에도 예외를 선언하는 방법이 있다. 메서드 내에서 발생할 수 있는 예외를 선언부에 throws와 함께 적어준다.
Java API에 보면 Throws에 뭘 써야 되는지 알려준다. RunTimeException이 아니면 메서드 선언할 때 적어야 한다.

8. 예외 되던지기(Exception re-throwing)
하나의 예외에 대해서 예외가 발생한 메서드와 이를 호출한 메서드 양쪽 모두에서 처리해줘야 할 작업이 있을 때 사용된다.
이 때 주의해야 할 점은 예외가 발생할 메서드에서는 try-catch 문을 사용해서 예외처리를 해줌과 동시에
메서드 선언부에 발생할 예외를 throws에 지정해줘야 한다는 것이다.