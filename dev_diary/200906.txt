1. 프로그램을 실행하면 프로세스가 된다. 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)를 할당받아 프로세스가 된다.

2. 프로세스는 자원(프로그램을 수행하는데 필요한 데이터와 메모리 등) + 쓰레드 로 구성되어 있다.
쓰레드를 자원을 가지고 작업을 처리하는 worker라고 생각해도 좋다.

3. 쓰레드가 작업을 할 때 Call stack이 필요하기 때문에 Call Stack의 크기에 따라 가능한 쓰레드 수가 결정된다.
여러 개의 프로그램이 OS에서 돌아가는 게 멀티태스킹이듯이, 하나의 프로세스에서 여러 쓰레드가 동시에 돌아가는 걸 멀티쓰레딩이라고 한다.
실제로는 한 개의 CPU는 한 가지 작업만 하기 때문에, 순식간에 여러 작업을 번갈아서 수행하는 것이다.

4. 멀티쓰레딩의 장점
- CPU의 사용률을 향상시킨다. 자원을 보다 효율적으로 사용할 수 있다. 사용자에 대한 응답성이 향상된다. 작업이 분리되어 코드가 간결해진다.

5. 쓰레드를 구현하는 방법 : Thread 클래스를 상속받는 방법 / Runnable 인터페이스를 구현하는 방법
Thread 클래스를 상속받으면 다른 클래스 상속 못 받기 때문에 보통 Runnable 인터페이스를 구현한다.

1) Thread 클래스 상속받은 경우
ThreadEx1_1 t1 = new ThreadEx1_1();

2) Runnable 인터페이스 구현한 경우
Runnable r = new ThreadEx1_2();
Thread t2 = new Thread(r);
// Thread t2 = new Thread(new ThreadEx1_2());

6. 쓰레드는 단 한 번만 호출될 수 있다.

7. start()와 run()
run()을 호출하면 생성된 쓰레드를 실행하는 게 아니라, 단순히 메서드 하나를 호출하는 것이다.
start()를 호출하면 아예 call stack을 하나 새로 만든다. 거기서 run()을 호출해서 run()이 new call stack의 첫 번째로 저장한다.
이제 호출스택이 2개이기 때문에 스케줄러가 정한 순서에 의해서 번갈아 가면서 실행된다.
작업 마치면 생성된 스택은 소멸된다.
실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램이 종료된다.

8. 멀티쓰레드는 CPU이외의 자원을 사용하는 작업의 경우 효과적이다.

9. 쓰레드에도 priority가 존재한다. 우선순위의 범위는 1~10이며 숫자가 높을수록 우선순위가 높아진다.
쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다. main메소드는 우선순위 5이므로 자동적으로 이렇게 된다.

10. 쓰레드 그룹. 쓰레드도 그룹지을 수 있다. main이랑 system 그룹은 자동 생성되는데 그룹 지정 안하면 자동으로 main 쓰레드그룹이다.
가비지컬렉션 수행하는 Finalizer 쓰레드는 system 쓰레드 그룹에 속한다.

11. 데몬 쓰레드(Daemon thread)는 일반 쓰레드의 작업을 돕는 보조적인 역할을 하는 쓰레드이다.
데몬 쓰레드의 예 : 가비지 컬렉터, 워드프로세서의 자동저장, 화면 자동갱신 등
데몬 쓰레드는 무한루프와 조건문으로 실행 후 대기하고 있다가 특정 조건이 만족되면 작업 수행 후 다시 대기한다.

12. 쓰레드 프로그래밍은 동기화와 스케쥴링이 매우 중요하다.
join을 쓰면 한 쓰레드의 작업 중간에 다른 쓰레드의 작업을 넣을 수 있다.
suspend(), sleep(), resume(), yield()를 하면 어떻게 되는지 책 646쪽 그림을 통해서 잘 이해하고 있어야 된다.

13. 메서드에 synchronized를 걸면 메서드 종료될 때까지 다른 쓰레드가 이 메서드 호출할 수 없음.
근데 이러다 교착 상태(dead lock)에 빠질 수도 있다. 그래서 이제부터는 suspend 대신 wait, resume 대신 notify를 사용한다.

